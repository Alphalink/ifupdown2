#!/usr/bin/python

import sys
import os
import re
import argparse
from ifupdown.ifupdownmain import *

import logging

lockfile="/run/network/.lock"
logger = None

def run(args, op):
    logger.debug('args = %s' %str(args))

    try:
        iflist = args.iflist
        if len(args.iflist) == 0:
            iflist = None

        cachearg=False if iflist is not None or args.nocache == True else True
        logger.debug('creating ifupdown object ..')
        if op == 'up' or op == 'down' or op == 'reload':
            ifupdown_handle = ifupdownMain(force=args.force,
                                            nodepends=args.nodepends,
                                            perfmode=args.perfmode,
                                            njobs=args.jobs,
                                            dryrun=args.noact,
                                            cache=cachearg)
        elif op == 'query':
            ifupdown_handle = ifupdownMain(nodepends=args.nodepends,
                                            perfmode=args.perfmode,
                                            njobs=args.jobs,
                                            format=args.format,
                                            cache=cachearg)

        logger.debug('calling %s' %op + ' for all interfaces ..')
        if op == 'up':
            ifupdown_handle.up(args.all, args.CLASS, iflist,
                               excludepats=args.excludepats,
                               printdependency=args.printdependency)
        elif op == 'down':
            ifupdown_handle.down(args.all, args.CLASS, iflist,
                                 excludepats=args.excludepats)
        elif op == 'query':
            if args.checkcurstate == True:
                qtype='query-checkcurr'
            elif args.presumedstate == True:
                qtype='query-presumed'
            elif args.presumedstatedetailed == True:
                qtype='query-presumeddetailed'
            elif args.runningstate == True:
                if iflist is None:
                    iflist = [i for i in os.listdir('/sys/class/net/')
                              if os.path.isdir('/sys/class/net/%s' %i) == True]
                    print iflist
                qtype='query-running'
            else:
                qtype='query'

            ifupdown_handle.query(qtype, args.all, args.CLASS, iflist,
                                  excludepats=args.excludepats)
        elif op == 'reload':
            if iflist is not None:
                raise Exception('iflist is currently not supported with reload')

            ifupdown_handle.reload(args.all, args.CLASS, iflist,
                               excludepats=args.excludepats)
    except:
        raise

def init(args):
    global logger

    log_level = logging.WARNING

    if args.verbose == True:
        log_level = logging.INFO

    if args.debug == True:
        log_level = logging.DEBUG

    try:
        logging.basicConfig(level=log_level,
            format='%(levelname)s: %(message)s')
        logger = logging.getLogger('ifupdown')
    except:
        raise


def deinit():
    {}

def update_argparser(argparser):
    """ base parser """
    argparser.add_argument('iflist', metavar='IFACE',
                nargs='*', help='interfaces list')
    argparser.add_argument('-v', '--verbose', dest='verbose',
                action='store_true', help='verbose')
    argparser.add_argument('-d', '--debug', dest='debug',
                action='store_true',
                help='output debug info')
    argparser.add_argument('-q', '--quiet', dest='quiet',
                action='store_true',
                help=argparse.SUPPRESS)
    argparser.add_argument('--allow', dest='CLASS', 
                help='ignore non-\"allow-CLASS\" interfaces')
    argparser.add_argument('--nodepends', dest='nodepends',
                action='store_true', help=argparse.SUPPRESS)
    argparser.add_argument('--perfmode', dest='perfmode',
                action='store_true', help=argparse.SUPPRESS)
    argparser.add_argument('-j', '--jobs', dest='jobs', type=int,
                default=-1, choices=range(1,12), help=argparse.SUPPRESS)
    argparser.add_argument('--nocache', dest='nocache', action='store_true',
                help=argparse.SUPPRESS)
    argparser.add_argument('--print-dependency',
                dest='printdependency', choices=['list', 'dot'],
                help=argparse.SUPPRESS)
    argparser.add_argument('-X', '--exclude', dest='excludepats',
                action='append', help='exclude interfaces from the list of '
                + 'interfaces to operate on by a PATTERN '
                + '(note that this option doesn\'t disable mappings)')


def update_ifupdown_argparser(argparser):
    argparser.add_argument('-a', '--all', action='store_true',
                help='process all interfaces marked \"auto\"')
    argparser.add_argument('-f', '--force', dest='force',
                action='store_true',
                help='force run all operations')
    argparser.add_argument('-n', '--no-act', dest='noact',
                action='store_true', help='print out what would happen,' +
                'but don\'t do it')

def update_ifup_argparser(argparser):
    update_ifupdown_argparser(argparser)

def update_ifdown_argparser(argparser):
    update_ifupdown_argparser(argparser)

def update_ifquery_argparser(argparser):
    argparser.add_argument('-l', '--list', action='store_true', dest='all',
                help='process all interfaces marked \"auto\"')
    group = argparser.add_mutually_exclusive_group(required=False)
    group.add_argument('-r', '--running-state', dest='runningstate',
                       action='store_true',
                       help='query running state of an interface')

    group.add_argument('-c', '--check-state', dest='checkcurstate',
                       action='store_true',
                       help='check running state of an interface')

    # presumed-state is state maintained by ifupdown
    group.add_argument('--presumed-state', dest='presumedstate',
                       action='store_true', help=argparse.SUPPRESS)

    # presumed-state-detailed prints all details about the object stored
    # by ifupdown
    group.add_argument('--presumed-state-detailed',
                       dest='presumedstatedetailed',
                       action='store_true', help=argparse.SUPPRESS)

    group.add_argument('--format', dest='format', default='nwifaces',
                       choices=['nwifaces', 'json'], help=argparse.SUPPRESS)

def update_ifreload_argparser(argparser):
    update_ifupdown_argparser(argparser)

def parse_args(argsv, op):
    descr = 'interface management'

    argparser = argparse.ArgumentParser(description=descr)
    update_argparser(argparser)
    if op == 'up':
        update_ifup_argparser(argparser)
    elif op == 'down':
        update_ifdown_argparser(argparser)
    elif op == 'query':
        update_ifquery_argparser(argparser)
    elif op == 'reload':
        update_ifreload_argparser(argparser)

    return argparser.parse_args(argsv)

def main(argv):
    """ main function """
    try:
        op = None
        if re.search(r'ifup', argv[0]) != None:
            op = 'up'
        elif re.search(r'ifdown', argv[0]) != None:
            op = 'down'
        elif re.search(r'ifquery', argv[0]) != None:
            op = 'query'
        elif re.search(r'ifreload', argv[0]) != None:
            op = 'reload'
        else:
            print ('Unexpected executable.' +
                   ' Should be \'ifup\' or \'ifdown\' or \'ifquery\'')
            exit(1)

        # Command line arg parser
        args = parse_args(argv[1:], op)
        if len(args.iflist) > 0 and args.all is True:
            print 'interface list cannot be specified with all option'
            exit(1)

        init(args)
        run(args, op)
    except Exception, e:
        if str(e) == '':
            exit(1)

        if args.debug == True:
            raise
        else:
            logger.error(str(e))
            print '\nRerun the command with \'-d\' for a detailed errormsg'
        exit(1)
    finally:
        deinit()

if __name__ == "__main__":

    if not os.geteuid() == 0:
        print 'Error: Must be root to run this command'
        exit(1)

    """
    XXX: Cannot use this. A spawned dhclient process can hold the lock
    if not utilities.lockFile(lockfile):
        print 'Another instance of this program is already running.'
        exit(0)
    """

    main(sys.argv)
