#!/usr/bin/python

import sys
import os
import re
import argparse
from ifupdown.ifupdownmain import *

import logging

lockfile="/run/network/.lock"
logger = None

def run(args, op):
    logger.debug('args = %s' %str(args))

    try:
        iflist = args.iflist
        if len(args.iflist) == 0:
            iflist = None
        logger.debug('creating ifupdown object ..')
        if op == 'up' or op == 'down' or op == 'reload':
            cachearg=(False if (iflist or args.nocache or
                            args.perfmode or args.noact)
                            else True)
            ifupdown_handle = ifupdownMain(force=args.force,
                                            withdepends=args.withdepends,
                                            perfmode=args.perfmode,
                                            njobs=args.jobs,
                                            dryrun=args.noact,
                                            cache=cachearg)
        elif op == 'query':
            cachearg=(False if (iflist or args.nocache or
                            args.perfmode or args.syntaxhelp) else True)
            ifupdown_handle = ifupdownMain(withdepends=args.withdepends,
                                            perfmode=args.perfmode,
                                            njobs=args.jobs,
                                            cache=cachearg)

        logger.debug('calling \'%s\'' %op + ' for all interfaces ..')
        if op == 'up':
            ifupdown_handle.up(['pre-up', 'up', 'post-up'],
                               args.all, args.CLASS, iflist,
                               excludepats=args.excludepats,
                               printdependency=args.printdependency)
        elif op == 'down':
            ifupdown_handle.down(['pre-down', 'down', 'post-down'],
                                 args.all, args.CLASS, iflist,
                                 excludepats=args.excludepats,
                                 printdependency=args.printdependency)
        elif op == 'query':
            if args.checkcurstate:
                qop='query-checkcurr'
            elif args.runningstate:
                if iflist is None:
                    iflist = [i for i in os.listdir('/sys/class/net/')
                              if os.path.isdir('/sys/class/net/%s' %i)]
                qop='query-running'
            elif args.raw:
                qop='query-raw'
            elif args.syntaxhelp:
                qop = 'query-syntax'
            elif args.printdependency:
                qop = 'query-dependency'
            else:
                qop='query'

            ifupdown_handle.query([qop], args.all, args.CLASS, iflist,
                                  excludepats=args.excludepats,
                                  printdependency=args.printdependency,
                                  format=args.format)
        elif op == 'reload':
            if iflist is not None:
                raise Exception('iflist is currently not supported with reload')
            ifupdown_handle.reload(args.all, args.CLASS, iflist,
                                   excludepats=args.excludepats,
                                   downchangediface=args.downchangediface)
    except:
        raise

def init(args):
    global logger

    log_level = logging.WARNING

    if args.verbose == True:
        log_level = logging.INFO

    if args.debug == True:
        log_level = logging.DEBUG

    try:
        logging.basicConfig(level=log_level,
            format='%(levelname)s: %(message)s')
        logger = logging.getLogger('ifupdown')
    except:
        raise


def deinit():
    {}

def update_argparser(argparser):
    """ base parser, common to all commands """

    argparser.add_argument('-a', '--all', action='store_true', required=False,
                help='process all interfaces marked \"auto\"')
    argparser.add_argument('iflist', metavar='IFACE',
                nargs='*', help='interface list separated by spaces')

    argparser.add_argument('-v', '--verbose', dest='verbose',
                action='store_true', help='verbose')
    argparser.add_argument('-d', '--debug', dest='debug',
                action='store_true',
                help='output debug info')
    argparser.add_argument('-q', '--quiet', dest='quiet',
                action='store_true',
                help=argparse.SUPPRESS)
    argparser.add_argument('--allow', dest='CLASS', 
                help='ignore non-\"allow-CLASS\" interfaces')
    argparser.add_argument('--with-depends', dest='withdepends',
                action='store_true', help='run with all dependent interfaces')
    argparser.add_argument('--perfmode', dest='perfmode',
                action='store_true', help=argparse.SUPPRESS)
    argparser.add_argument('-j', '--jobs', dest='jobs', type=int,
                default=-1, choices=range(1,12), help=argparse.SUPPRESS)
    argparser.add_argument('--nocache', dest='nocache', action='store_true',
                help=argparse.SUPPRESS)
    argparser.add_argument('-X', '--exclude', dest='excludepats',
                action='append',
                help='Exclude interfaces from the list of interfaces' +
                ' to operate on')

def update_ifupdown_argparser(argparser):
    """ common arg parser for ifup and ifdown """
    argparser.add_argument('-f', '--force', dest='force',
                action='store_true',
                help='force run all operations')
    argparser.add_argument('-n', '--no-act', dest='noact',
                action='store_true', help='print out what would happen,' +
                'but don\'t do it')
    argparser.add_argument('--print-dependency',
                dest='printdependency', choices=['list', 'dot'],
                help='print iface dependency')

def update_ifup_argparser(argparser):
    update_ifupdown_argparser(argparser)

def update_ifdown_argparser(argparser):
    update_ifupdown_argparser(argparser)

def update_ifquery_argparser(argparser):
    """ arg parser for ifquery options """

    # -l is same as '-a', only here for backward compatibility
    argparser.add_argument('-l', '--list', action='store_true', dest='all',
                help=argparse.SUPPRESS)
    group = argparser.add_mutually_exclusive_group(required=False)
    group.add_argument('-r', '--running-state', dest='runningstate',
                       action='store_true',
                       help='query running state of an interface')
    group.add_argument('-c', '--check-state', dest='checkcurstate',
                       action='store_true',
                       help='check running against config of an interface')
    group.add_argument('--raw', action='store_true', dest='raw',
                       help='print raw config file entries')
    argparser.add_argument('--format', dest='format', default='native',
                       choices=['native', 'json'], help=argparse.SUPPRESS)
    argparser.add_argument('--print-dependency',
                           dest='printdependency', choices=['list', 'dot'],
                           help='print interface dependency')
    argparser.add_argument('--syntax-help', action='store_true',
                           dest='syntaxhelp',
                           help='print supported interface config syntax')

def update_ifreload_argparser(argparser):
    update_ifupdown_argparser(argparser)
    argparser.add_argument('--down-changediface', dest='downchangediface',
                action='store_true',
                help='down interfaces that have changed before bringing them up')

def parse_args(argsv, op):
    if op == 'query':
        descr = 'query interfaces (all or interface list)'
    else:
        descr = 'interface management'
    argparser = argparse.ArgumentParser(description=descr)
    update_argparser(argparser)
    if op == 'up':
        update_ifup_argparser(argparser)
    elif op == 'down':
        update_ifdown_argparser(argparser)
    elif op == 'query':
        update_ifquery_argparser(argparser)
    elif op == 'reload':
        update_ifreload_argparser(argparser)
    return argparser.parse_args(argsv)

def main(argv):
    """ main function """
    try:
        op = None
        if re.search(r'ifup', argv[0]) != None:
            op = 'up'
        elif re.search(r'ifdown', argv[0]) != None:
            op = 'down'
        elif re.search(r'ifquery', argv[0]) != None:
            op = 'query'
        elif re.search(r'ifreload', argv[0]) != None:
            op = 'reload'
        else:
            print ('Unexpected executable.' +
                   ' Should be \'ifup\' or \'ifdown\' or \'ifquery\'')
            exit(1)
        # Command line arg parser
        args = parse_args(argv[1:], op)
        if not len(args.iflist) and not args.all and not args.syntaxhelp:
            print '\'-a\' option or interface list are required'
            exit(1)
        if len(args.iflist) and args.all:
            print '\'-a\' option and interface list are mutually exclusive'
            exit(1)
        init(args)
        run(args, op)
    except Exception, e:
        if str(e) == '':
            exit(1)
        if args.debug:
            raise
        else:
            logger.error(str(e))
            if not args.debug:
                print '\nRerun the command with \'-d\' for a detailed errormsg'
        exit(1)
    finally:
        deinit()

if __name__ == "__main__":

    if not os.geteuid() == 0:
        print 'Error: Must be root to run this command'
        exit(1)

    """
    XXX: Cannot use this. A spawned dhclient process can hold the lock
    if not utilities.lockFile(lockfile):
        print 'Another instance of this program is already running.'
        exit(0)
    """

    main(sys.argv)
